@using FluentValidation
<EditForm Model="@_model" OnValidSubmit="OnValidSubmit">
    <FluentValidationValidator/>

    <div class="grid mb-3 mb-sm-6">
        @foreach (var option in Options)
        {
            var (icon, color) = Get(option);

            <div class="d-flex flex-row align-center">
                @if (icon is null)
                {
                    <span style="width: 24px">&nbsp;</span>
                }
                else
                {
                    <MudIcon Icon="@icon" Color="@color"/>
                }

                <MudCheckBox
                    Checked="@(_model.Numbers.Contains(option.Number))"
                    CheckedChanged="@((bool b) => OnChecked(b, option.Number))"
                    Disabled="@(_result != null)"
                    Color="Color.Primary">
                    @switch (option.Type)
                    {
                        case AnswerOptionType.Text:
                            <MudText Typo="Typo.body1">
                                @option.Value
                            </MudText>
                            break;

                        case AnswerOptionType.Image:
                            <div class="image">
                                <img src="@option.Value" alt="@option.Value"/>
                            </div>
                            break;
                    }
                </MudCheckBox>
            </div>
        }
    </div>

    <div class="d-flex flex-row justify-center mb-3 mb-sm-6">
        @if (_result is null)
        {
            <LoadingButton
                ButtonType="ButtonType.Submit"
                Variant="Variant.Filled"
                Color="Color.Primary"
                IsLoading="@_isLoading"
                Text="@L["Test:Answer"]"
                LoadingText="@L["Loading"]"/>
        }
        else if (_result is {IsTestComplete: true})
        {
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@OnComplete">
                @L["Test:Result"]
            </MudButton>
        }
        else if (_result is {IsTestComplete: false})
        {
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="@OnNext">
                @L["Test:Next"]
            </MudButton>
        }
    </div>

    <div class="d-flex flex-row justify-center">
        @if (_result is null)
        {
            <MudText Typo="Typo.subtitle2" Align="Align.Center" Color="@Color.Error">
                <ValidationSummary/>
            </MudText>
        }
        else if (_result is {IsCorrect: true})
        {
            <MudText Typo="Typo.subtitle2" Color="@Color.Success">
                @L["Test:CorrectAnswer"]
            </MudText>
        }
        else if (_result is {IsCorrect: false})
        {
            <MudText Typo="Typo.subtitle2" Color="@Color.Error">
                @L["Test:IncorrectAnswer"]
            </MudText>
        }
    </div>
</EditForm>

@code {
    private Model _model = new();
    private ManyAnswersResult? _result;
    private bool _isLoading;

    [Inject]
    private IStringLocalizer<App> L { get; set; } = default!;

    [Parameter, EditorRequired]
    public AnswerOption[] Options { get; set; } = Array.Empty<AnswerOption>();

    [Parameter, EditorRequired]
    public Func<ManyAnswer, Task<ManyAnswersResult>> OnAnswer { get; set; } = default!;

    [Parameter, EditorRequired]
    public EventCallback OnNext { get; set; }

    [Parameter, EditorRequired]
    public EventCallback OnComplete { get; set; }

    protected override void OnParametersSet()
    {
        _isLoading = false;
        _result = null;
        _model = new Model();
    }

    private async Task OnValidSubmit()
    {
        _isLoading = true;
        _result = await OnAnswer(new ManyAnswer(_model.Numbers));
        _isLoading = false;
    }

    private void OnChecked(bool isAdded, int number)
    {
        if (isAdded)
            _model.Numbers.Add(number);
        else
            _model.Numbers.Remove(number);
    }

    private (string? Icon, Color Color) Get(AnswerOption option) =>
        _result switch {
        { } x when x.Numbers.Contains(option.Number) => 
            (Icon: Icons.Filled.Check , Color: Color.Success),
                                                
        {IsCorrect: false} when _model.Numbers.Contains(option.Number) => 
            (Icon: Icons.Filled.Clear , Color: Color.Error),
            
            _ => (Icon: null, Color: Color.Default)
            };

    public record Model
    {
        public List<int> Numbers { get; set; } = new();

        public class Validator : AbstractValidator<Model>
        {
            public Validator(IStringLocalizer<App> localizer) => RuleFor(x => x.Numbers)
                .NotEmpty()
                .WithMessage(localizer["Test:AnswerCannotBeEmpty"]);
        }
    }

}