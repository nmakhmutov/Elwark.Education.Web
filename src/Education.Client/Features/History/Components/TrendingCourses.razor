@using Education.Client.Features.History.Clients.Course
@using Education.Client.Features.History.Clients.Course.Request
@using Education.Client.Features.History.Clients.Learner
@implements IAsyncDisposable;

<section class="grid @Class">
    <ApiViewer Result="@_result" OnReloadClick="@OnInitializedAsync">
        <Loading>
            @for (var i = 0; i < 6; i++)
            {
                <SkeletonCard Horizontal="@IsHorizontal(i)" HideFooter="IsHiddenOverview(i)"/>
            }
        </Loading>
        <ChildContent Context="courses">
            @for (var i = 0; i < courses.Length; i++)
            {
                var course = courses[i];

                <CourseCard
                    Course="@course.Course"
                    Activity="@course.Activity"
                    HasExamination="@course.HasExamination"
                    OnBookmarkClick="@LearnerClient.ToggleCourseBookmarkAsync"
                    Horizontal="@IsHorizontal(i)"
                    HideOverview="@IsHiddenOverview(i)"
                    OneLineTitle/>
            }
        </ChildContent>
    </ApiViewer>
</section>

@code {
    private Guid _subscriptionId;
    private Breakpoint _breakpoint;

    private ApiResult<UserCourseOverviewModel[]> _result = ApiResult<UserCourseOverviewModel[]>.Loading();

    [Inject]
    private IBrowserViewportService ViewportService { get; init; } = default!;

    [Inject]
    private IHistoryCourseClient CourseClient { get; init; } = default!;

    [Inject]
    private IHistoryLearnerClient LearnerClient { get; init; } = default!;

    [Parameter]
    public string? Class { get; set; }

    protected override async Task OnInitializedAsync() =>
        _result = (await CourseClient.GetAsync(new GetCourseRequest(GetCourseRequest.SortType.Trending, 0, 6)))
            .Map(x => x.Items);

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return Task.CompletedTask;

        _subscriptionId = Guid.NewGuid();
        var options = new ResizeOptions { NotifyOnBreakpointOnly = true };
        return ViewportService.SubscribeAsync(_subscriptionId, x => OnBreakpointChanged(x.Breakpoint), options);
    }

    private void OnBreakpointChanged(Breakpoint breakpoint)
    {
        _breakpoint = breakpoint;
        InvokeAsync(StateHasChanged);
    }

    private bool IsHorizontal(int i) =>
        _breakpoint >= Breakpoint.Lg && i > 0;

    private bool IsHiddenOverview(int i) =>
        _breakpoint >= Breakpoint.Lg && i > 2;

    public async ValueTask DisposeAsync() =>
        await ViewportService.UnsubscribeAsync(_subscriptionId);

}